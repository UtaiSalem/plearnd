<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HexagonAvatar Test</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .test-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 30px;
        }
        .test-item {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            text-align: center;
        }
        .test-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #333;
        }
    </style>
</head>
<body>
    <div id="app">
        <h1>HexagonAvatar Component Test</h1>
        
        <h2>ทดสอบระดับชั้น 1-6</h2>
        <div class="test-container">
            <div v-for="grade in 6" :key="grade" class="test-item">
                <div class="test-title">ชั้น {{ grade }}</div>
                <hexagon-avatar
                    :image-src="'https://picsum.photos/seed/grade' + grade + '/200/200.jpg'"
                    :grade-level="grade"
                    :border-layers="grade"
                    :completed-sides="grade === 6 ? 6 : grade - 1"
                    :level="grade"
                />
            </div>
        </div>
        
        <h2>ทดสอบความคืบหน้าในชั้นเรียน (ม.4)</h2>
        <div class="test-container">
            <div v-for="sides in 7" :key="sides" class="test-item">
                <div class="test-title">ม.4 - เสร็จ {{ sides - 1 }}/6 ด้าน</div>
                <hexagon-avatar
                    :image-src="'https://picsum.photos/seed/progress' + sides + '/200/200.jpg'"
                    grade-level="4"
                    :border-layers="2"
                    :completed-sides="sides - 1"
                    :level="25"
                />
            </div>
        </div>
        
        <h2>ทดสอบขนาด Badge</h2>
        <div class="test-container">
            <div class="test-item">
                <div class="test-title">Badge ปกติ</div>
                <hexagon-avatar
                    image-src="https://picsum.photos/seed/badge1/200/200.jpg"
                    grade-level="3"
                    :border-layers="3"
                    :completed-sides="2"
                    level="25"
                />
            </div>
            <div class="test-item">
                <div class="test-title">Badge เล็กลง</div>
                <hexagon-avatar
                    image-src="https://picsum.photos/seed/badge2/200/200.jpg"
                    grade-level="3"
                    :border-layers="3"
                    :completed-sides="2"
                    level="25"
                    :badge-size="16"
                />
            </div>
        </div>
    </div>

    <script>
        const { createApp } = Vue;

        // HexagonAvatar Component (simplified version for testing)
        const HexagonAvatar = {
            template: `
                <div class="hexagon-avatar-container" :style="containerStyle">
                    <canvas 
                        ref="hexagonCanvas"
                        :width="width"
                        :height="height"
                        :style="canvasStyle"
                    ></canvas>
                    <div v-if="showBadge" class="hexagon-badge" :style="badgeStyle">
                        {{ level }}
                    </div>
                </div>
            `,
            props: {
                width: { type: Number, default: 82 },
                height: { type: Number, default: 90 },
                imageSrc: { type: String, required: true },
                level: { type: [String, Number], default: '' },
                lineColor: { type: String, default: '#ffffff' },
                lineWidth: { type: Number, default: 7 },
                roundedCorners: { type: Boolean, default: true },
                roundedCornerRadius: { type: Number, default: 9 },
                fillColor: { type: String, default: '#45437f' },
                showBadge: { type: Boolean, default: true },
                badgeSize: { type: Number, default: 22 },
                educationLevel: { 
                    type: String, 
                    default: 'elementary',
                    validator: (value) => ['elementary', 'secondary', 'university'].includes(value)
                },
                gradeLevel: {
                    type: Number,
                    default: 1,
                    validator: (value) => value >= 1 && value <= 6
                },
                borderLayers: {
                    type: Number,
                    default: 1,
                    validator: (value) => value >= 1 && value <= 6
                },
                completedSides: {
                    type: Number,
                    default: 0,
                    validator: (value) => value >= 0 && value <= 6
                },
                responsive: { type: Boolean, default: false },
                maxWidth: { type: Number, default: 150 }
            },
            emits: ['loaded'],
            setup(props, { emit }) {
                const { ref, computed, onMounted, watch } = Vue;
                const hexagonCanvas = ref(null);
                const isLoaded = ref(false);

                const containerStyle = computed(() => {
                    const style = { position: 'relative' };
                    if (props.responsive) {
                        style.width = '100%';
                        style.maxWidth = `${props.maxWidth}px`;
                        style.height = 'auto';
                        style.aspectRatio = `${props.width} / ${props.height}`;
                    } else {
                        style.width = `${props.width}px`;
                        style.height = `${props.height}px`;
                    }
                    return style;
                });

                const canvasStyle = computed(() => {
                    const style = {
                        position: 'absolute',
                        top: 0,
                        left: 0
                    };
                    if (props.responsive) {
                        style.width = '100%';
                        style.height = '100%';
                    }
                    return style;
                });

                const educationLevelColors = computed(() => {
                    switch (props.educationLevel) {
                        case 'elementary':
                            return '#4CAF50';
                        case 'secondary':
                            return '#2196F3';
                        case 'university':
                            return '#9C27B0';
                        default:
                            return '#4CAF50';
                    }
                });

                const gradeLevelColors = computed(() => {
                    switch (props.gradeLevel) {
                        case 1:
                            return '#FF6B6B';
                        case 2:
                            return '#4ECDC4';
                        case 3:
                            return '#45B7D1';
                        case 4:
                            return '#96CEB4';
                        case 5:
                            return '#DDA0DD';
                        case 6:
                            return '#FFD700';
                        default:
                            return '#FF6B6B';
                    }
                });

                const levelBorderColor = computed(() => {
                    const level = parseInt(props.level) || 0;
                    if (level >= 50) return '#FFD700';
                    else if (level >= 40) return '#C0C0C0';
                    else if (level >= 30) return '#CD7F32';
                    else if (level >= 20) return '#9370DB';
                    else if (level >= 10) return '#4169E1';
                    else return '#32CD32';
                });

                const badgeStyle = computed(() => {
                    const badgeSize = props.responsive ? 
                        Math.max(12, Math.min(32, props.width * 0.25)) : 
                        Math.max(12, props.badgeSize * 0.7);
                    
                    return {
                        position: 'absolute',
                        bottom: props.responsive ? '-5%' : '-8px',
                        right: props.responsive ? '-5%' : '-8px',
                        width: `${badgeSize}px`,
                        height: `${badgeSize + 2}px`,
                        backgroundColor: levelBorderColor.value,
                        color: '#ffffff',
                        borderRadius: '50%',
                        display: 'flex',
                        alignItems: 'center',
                        justifyContent: 'center',
                        fontSize: props.responsive ? `${Math.max(7, badgeSize * 0.35)}px` : '8px',
                        fontWeight: 'bold',
                        zIndex: 10,
                        boxShadow: '0 2px 4px rgba(0, 0, 0, 0.2)'
                    }
                });

                function initHexagon() {
                    const canvas = hexagonCanvas.value;
                    if (!canvas) return;
                    
                    const ctx = canvas.getContext('2d');
                    
                    const img = new Image();
                    img.onload = () => {
                        drawHexagon(ctx, img);
                        isLoaded.value = true;
                        emit('loaded');
                    };
                    img.src = props.imageSrc;
                }

                function drawHexagon(ctx, img) {
                    const { width, height } = props;
                    
                    ctx.clearRect(0, 0, width, height);
                    
                    ctx.save();
                    createHexagonPath(ctx);
                    ctx.clip();
                    
                    const imgSize = Math.max(width, height);
                    const offsetX = (width - imgSize) / 2;
                    const offsetY = (height - imgSize) / 2;
                    
                    ctx.drawImage(img, offsetX, offsetY, imgSize, imgSize);
                    ctx.restore();
                    
                    drawHexagonBorders(ctx);
                    
                    if (props.showBadge) {
                        drawHexagonBadge();
                    }
                }

                function drawHexagonBadge() {
                    const canvas = badgeCanvas.value;
                    if (!canvas) return;
                    
                    const ctx = canvas.getContext('2d');
                    const size = badgeSize.value;
                    
                    ctx.clearRect(0, 0, size, size);
                    
                    const centerX = size / 2;
                    const centerY = size / 2;
                    const radius = size / 2 - 2;
                    
                    ctx.beginPath();
                    const angleStep = Math.PI / 3;
                    let angle = Math.PI / 2;
                    
                    for (let i = 0; i <= 6; i++) {
                        const x = centerX + radius * Math.cos(angle);
                        const y = centerY + radius * Math.sin(angle);
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                        
                        angle += angleStep;
                    }
                    
                    ctx.closePath();
                    
                    ctx.fillStyle = levelBorderColor.value;
                    ctx.fill();
                    
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }

                function createHexagonPath(ctx) {
                    const { width, height, roundedCorners, roundedCornerRadius } = props;
                    const centerX = width / 2;
                    const centerY = height / 2;
                    const radiusX = width / 2 - (props.lineWidth * props.borderLayers) / 2;
                    const radiusY = height / 2 - (props.lineWidth * props.borderLayers) / 2;
                    
                    ctx.beginPath();
                    
                    if (roundedCorners && roundedCornerRadius > 0) {
                        drawPerfectRoundedHexagon(ctx, centerX, centerY, radiusX, radiusY, roundedCornerRadius);
                    } else {
                        drawPerfectHexagon(ctx, centerX, centerY, radiusX, radiusY);
                    }
                    
                    ctx.closePath();
                }

                function drawPerfectHexagon(ctx, centerX, centerY, radiusX, radiusY) {
                    const angleStep = Math.PI / 3;
                    let angle = Math.PI / 2;
                    
                    for (let i = 0; i <= 6; i++) {
                        const x = centerX + radiusX * Math.cos(angle);
                        const y = centerY + radiusY * Math.sin(angle);
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                        
                        angle += angleStep;
                    }
                }

                function drawPerfectRoundedHexagon(ctx, centerX, centerY, radiusX, radiusY, radius) {
                    const angleStep = Math.PI / 3;
                    const points = [];
                    
                    for (let i = 0; i < 6; i++) {
                        const angle = Math.PI / 2 + (i * angleStep);
                        points.push({
                            x: centerX + radiusX * Math.cos(angle),
                            y: centerY + radiusY * Math.sin(angle)
                        });
                    }
                    
                    for (let i = 0; i < 6; i++) {
                        const current = points[i];
                        const next = points[(i + 1) % 6];
                        const prev = points[(i + 5) % 6];
                        
                        const dx1 = current.x - prev.x;
                        const dy1 = current.y - prev.y;
                        const len1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);
                        
                        const dx2 = next.x - current.x;
                        const dy2 = next.y - current.y;
                        const len2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);
                        
                        const startX = current.x - (dx1 / len1) * radius;
                        const startY = current.y - (dy1 / len1) * radius;
                        
                        const endX = current.x + (dx2 / len2) * radius;
                        const endY = current.y + (dy2 / len2) * radius;
                        
                        if (i === 0) {
                            ctx.moveTo(startX, startY);
                        } else {
                            ctx.lineTo(startX, startY);
                        }
                        
                        ctx.quadraticCurveTo(current.x, current.y, endX, endY);
                    }
                }

                function drawHexagonBorders(ctx) {
                    const { lineWidth, width, height } = props;
                    const colors = gradeLevelColors.value;
                    
                    for (let layer = props.borderLayers - 1; layer >= 0; layer--) {
                        const layerOffset = layer * lineWidth;
                        const adjustedLineWidth = lineWidth;
                        
                        if (props.gradeLevel === 6) {
                            ctx.strokeStyle = colors;
                        } else {
                            ctx.strokeStyle = colors[layer];
                        }
                        
                        ctx.lineWidth = adjustedLineWidth;
                        ctx.lineCap = 'round';
                        ctx.lineJoin = 'round';
                        
                        ctx.beginPath();
                        const centerX = width / 2;
                        const centerY = height / 2;
                        const radiusX = width / 2 - layerOffset - adjustedLineWidth / 2;
                        const radiusY = height / 2 - layerOffset - adjustedLineWidth / 2;
                        
                        if (props.roundedCorners && props.roundedCornerRadius > 0) {
                            drawPerfectRoundedHexagon(ctx, centerX, centerY, radiusX, radiusY, props.roundedCornerRadius);
                        } else {
                            drawPerfectHexagon(ctx, centerX, centerY, radiusX, radiusY);
                        }
                        
                        ctx.closePath();
                        ctx.stroke();
                        
                        if (layer > 0) {
                            ctx.strokeStyle = '#ffffff';
                            ctx.lineWidth = 1;
                            
                            ctx.beginPath();
                            const whiteRadiusX = width / 2 - layerOffset - adjustedLineWidth + 1;
                            const whiteRadiusY = height / 2 - layerOffset - adjustedLineWidth + 1;
                            
                            if (props.roundedCorners && props.roundedCornerRadius > 0) {
                                drawPerfectRoundedHexagon(ctx, centerX, centerY, whiteRadiusX, whiteRadiusY, props.roundedCornerRadius);
                            } else {
                                drawPerfectHexagon(ctx, centerX, centerY, whiteRadiusX, whiteRadiusY);
                            }
                            
                            ctx.closePath();
                            ctx.stroke();
                        }
                    }
                }

                onMounted(() => {
                    initHexagon();
                });

                watch(() => props.imageSrc, () => {
                    initHexagon();
                });

                watch(() => props.width, () => {
                    initHexagon();
                });

                watch(() => props.height, () => {
                    initHexagon();
                });

                watch(() => props.level, () => {
                    initHexagon();
                });

                watch(() => props.educationLevel, () => {
                    initHexagon();
                });

                watch(() => props.gradeLevel, () => {
                    initHexagon();
                });

                watch(() => props.borderLayers, () => {
                    initHexagon();
                });

                return {
                    hexagonCanvas,
                    containerStyle,
                    canvasStyle,
                    badgeStyle
                };
            }
        };

        createApp({
            components: {
                HexagonAvatar
            }
        }).mount('#app');
    </script>

    <style scoped>
        .hexagon-avatar-container {
            display: inline-block;
            position: relative;
        }

        .hexagon-badge {
            font-family: Arial, sans-serif;
        }
    </style>
</body>
</html>